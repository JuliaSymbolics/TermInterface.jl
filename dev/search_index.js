var documenterSearchIndex = {"docs":
[{"location":"#TermInterface.jl-Documentation","page":"TermInterface.jl Documentation","title":"TermInterface.jl Documentation","text":"","category":"section"},{"location":"","page":"TermInterface.jl Documentation","title":"TermInterface.jl Documentation","text":"This package contains definitions for common functions that are useful for symbolic expression manipulation. Its purpose is to provide a shared interface between various symbolic programming Julia packages, for example  SymbolicUtils.jl, Symbolics.jl and Metatheory.jl.","category":"page"},{"location":"","page":"TermInterface.jl Documentation","title":"TermInterface.jl Documentation","text":"You should define the following methods for your expression tree type to work with TermInterface.jl, and therefore with SymbolicUtils.jl  and Metatheory.jl.","category":"page"},{"location":"#Examples","page":"TermInterface.jl Documentation","title":"Examples","text":"","category":"section"},{"location":"#Function-call-Julia-Expressions","page":"TermInterface.jl Documentation","title":"Function call Julia Expressions","text":"","category":"section"},{"location":"","page":"TermInterface.jl Documentation","title":"TermInterface.jl Documentation","text":"ex = :(f(a, b))\n@test head(ex) == :call\n@test children(ex) == [:f, :a, :b]\n@test operation(ex) == :f\n@test arguments(ex) == [:a, :b]\n@test isexpr(ex)\n@test iscall(ex)\n@test ex == maketerm(Expr, :call, [:f, :a, :b], nothing)","category":"page"},{"location":"#Non-function-call-Julia-Expressions","page":"TermInterface.jl Documentation","title":"Non-function call Julia Expressions","text":"","category":"section"},{"location":"","page":"TermInterface.jl Documentation","title":"TermInterface.jl Documentation","text":"ex = :(arr[i, j])\n@test head(ex) == :ref\n@test_throws ErrorException operation(ex)\n@test_throws ErrorException arguments(ex)\n@test isexpr(ex)\n@test !iscall(ex)\n@test ex == maketerm(Expr, :ref, [:arr, :i, :j], nothing)","category":"page"},{"location":"#API-Docs","page":"TermInterface.jl Documentation","title":"API Docs","text":"","category":"section"},{"location":"","page":"TermInterface.jl Documentation","title":"TermInterface.jl Documentation","text":"Modules = [TermInterface]","category":"page"},{"location":"#TermInterface.arguments","page":"TermInterface.jl Documentation","title":"TermInterface.arguments","text":"arguments(x)\n\nReturns the arguments to the function call in a function call expression. iscall(x) must be true as a precondition.\n\nDepending on the type and internal representation of x, arguments(x) may return an unsorted collection nondeterministically, This is to make sure to retrieve the arguments of an expression when the order of arguments does not matter  but the speed of the operation does. To ensure to retrieve arguments in a sorted manner, you can use  and implement the function sorted_arguments.\n\n\n\n\n\n","category":"function"},{"location":"#TermInterface.arity-Tuple{Any}","page":"TermInterface.jl Documentation","title":"TermInterface.arity","text":"arity(x)\n\nWhen x satisfies iscall, returns the number of arguments of x. Implicitly defined if arguments(x) is defined.\n\n\n\n\n\n","category":"method"},{"location":"#TermInterface.children","page":"TermInterface.jl Documentation","title":"TermInterface.children","text":"children(x)\n\nReturns the children (aka tail) of the S-expression.\n\nDepending on the type and internal representation of x, children(x) may return an unsorted collection nondeterministically, This is to make sure to retrieve the children of an AST node when the order of children does not matter, but the speed of the operation does. To ensure to retrieve children in a sorted manner, you can use  and implement the function sorted_children.\n\n\n\n\n\n","category":"function"},{"location":"#TermInterface.head","page":"TermInterface.jl Documentation","title":"TermInterface.head","text":"head(x)\n\nReturns the head of the S-expression.\n\n\n\n\n\n","category":"function"},{"location":"#TermInterface.is_operation-Tuple{Any}","page":"TermInterface.jl Documentation","title":"TermInterface.is_operation","text":"is_operation(f)\n\nReturns a single argument anonymous function predicate, that returns true if and only if the argument to the predicate satisfies iscall and operation(x) == f \n\n\n\n\n\n","category":"method"},{"location":"#TermInterface.iscall-Tuple{Any}","page":"TermInterface.jl Documentation","title":"TermInterface.iscall","text":"iscall(x)\n\nReturns true if x is a function call expression. If true, operation(x), arguments(x) must also be defined for x.\n\nIf iscall(x) is true, then also isexpr(x) must be true. The other way around is not true. (A function call is always an expression node, but not every expression tree represents a function call).\n\nThis means that, head(x) and children(x) must be defined. Together with operation(x) and arguments(x). \n\nExamples\n\nIn a functional language, all expression trees are function calls (e.g. SymbolicUtils.jl). Let's say that you have an hybrid array and functional language. iscall on the expression v[i] is false, and iscall on expression f(x) is true, but both of them are nested expressions, and isexpr is true on both.\n\nThe same goes for Julia Expr. An Expr(:block, ...) is not a function call and has no operation and arguments, but has a head and children.\n\nThe distinction between head/children and operation/arguments is needed  when dealing with languages that are not representing function call operations as their head. The main example is  Expr(:call, :f, :x): it has both a head and an operation, which are respectively :call and :f.\n\nIn other symbolic expression languages, such as SymbolicUtils.jl, the head of a node  can correspond to operation and children can correspond to arguments.\n\n\n\n\n\n","category":"method"},{"location":"#TermInterface.isexpr-Tuple{Any}","page":"TermInterface.jl Documentation","title":"TermInterface.isexpr","text":"isexpr(x)\n\nReturns true if x is an expression tree. If true, head(x) and children(x) methods must be defined for x. Optionally, if x represents a function call, iscall(x) should be true, and operation(x) and arguments(x) should also be defined. \n\n\n\n\n\n","category":"method"},{"location":"#TermInterface.maketerm","page":"TermInterface.jl Documentation","title":"TermInterface.maketerm","text":"maketerm(T, head, children, metadata)\n\nConstructs an expression. T is a constructor type, head and children are the head and tail of the S-expression. metadata is any metadata attached to this expression.\n\nNote that maketerm may not necessarily return an object of type T. For example, it may return a representation which is more efficient.\n\nThis function is used by term-manipulation routines to construct terms generically. In these routines, T is usually the type of the input expression which is being manipulated. For example, when a subexpression is substituted, the outer expression is re-constructed with the sub-expression. T will be the type of the outer expression.\n\nPackages providing expression types must implement this method for each expression type.\n\nGiving nothing for metadata should result in a default being selected.\n\n\n\n\n\n","category":"function"},{"location":"#TermInterface.metadata","page":"TermInterface.jl Documentation","title":"TermInterface.metadata","text":"metadata(expr, md)\n\nReturns a expr with metadata md attached to it.\n\n\n\n\n\n","category":"function"},{"location":"#TermInterface.metadata-Tuple{Any}","page":"TermInterface.jl Documentation","title":"TermInterface.metadata","text":"metadata(x)\n\nReturns the metadata attached to x.\n\n\n\n\n\n","category":"method"},{"location":"#TermInterface.node_count-Tuple{Any}","page":"TermInterface.jl Documentation","title":"TermInterface.node_count","text":"node_count(t) Count the nodes in a symbolic expression tree satisfying isexpr and arguments.\n\n\n\n\n\n","category":"method"},{"location":"#TermInterface.operation","page":"TermInterface.jl Documentation","title":"TermInterface.operation","text":"operation(x)\n\nReturns the function a function call expression is calling. iscall(x) must be true as a precondition.\n\n\n\n\n\n","category":"function"},{"location":"#TermInterface.sorted_arguments-Tuple{Any}","page":"TermInterface.jl Documentation","title":"TermInterface.sorted_arguments","text":"sorted_arguments(x::T)\n\nReturns the arguments to the function call in a function call expression, in a sorted fashion. iscall(x) must be true as a precondition. Analogous to arguments,  but ensures that the operation is deterministic and always returns  the arguments in the order they are stored.\n\nBy default, this redirects to arguments, therefore implementing  it is optional.\n\n\n\n\n\n","category":"method"},{"location":"#TermInterface.sorted_children-Tuple{Any}","page":"TermInterface.jl Documentation","title":"TermInterface.sorted_children","text":"sorted_children(x::T)\n\nReturns the children of an AST node, in a sorted fashion. isexpr(x) must be true as a precondition. Analogous to children,  but ensures that the operation is deterministic and always returns  the children in the order they are stored.\n\nBy default, this redirects to children, therefore implementing  it is optional.\n\n\n\n\n\n","category":"method"}]
}
